import srt # Changed from pysrt
import datetime # Added for timedelta
import math
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def format_ass_time(seconds: float) -> str:
    """
    Converts seconds (float) to H:MM:SS.ss string for ASS format.
    Example: 123.45 -> "0:02:03.45"
    """
    if not isinstance(seconds, (float, int)) or seconds < 0:
        logging.warning(f"Invalid seconds value for ASS time formatting: {seconds}. Returning default.")
        return "0:00:00.00"
        
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    centiseconds = int((seconds - int(seconds)) * 100)
    return f"{hours}:{minutes:02d}:{secs:02d}.{centiseconds:02d}"

def generate_srt(transcription_result: dict, output_srt_path: str) -> bool:
    """
    Generates an SRT subtitle file from Whisper's transcription result using the 'srt' library.

    Args:
        transcription_result: The result dictionary from Whisper's transcribe method.
        output_srt_path: The desired output path for the SRT file.

    Returns:
        True if SRT file creation is successful, False otherwise.
    """
    if not transcription_result or 'segments' not in transcription_result:
        logging.error("Invalid or empty transcription result for SRT generation.")
        return False

    subtitle_objects = []
    try:
        for i, segment in enumerate(transcription_result['segments']):
            start_time_s = segment.get('start')
            end_time_s = segment.get('end')
            text = segment.get('text', "").strip()

            if start_time_s is None or end_time_s is None:
                logging.warning(f"Skipping segment {i} due to missing start/end times.")
                continue

            start_delta = datetime.timedelta(seconds=start_time_s)
            end_delta = datetime.timedelta(seconds=end_time_s)

            sub = srt.Subtitle(
                index=i + 1,
                start=start_delta,
                end=end_delta,
                content=text
            )
            subtitle_objects.append(sub)
        
        srt_content = srt.compose(subtitle_objects)
        
        with open(output_srt_path, 'w', encoding='utf-8') as f:
            f.write(srt_content)
            
        logging.info(f"SRT file successfully generated at {output_srt_path}")
        return True
    except Exception as e:
        logging.error(f"Error generating SRT file at {output_srt_path}: {e}")
        return False

def generate_ass(transcription_result: dict, output_ass_path: str) -> bool:
    """
    Generates an ASS subtitle file from Whisper's transcription result.

    Args:
        transcription_result: The result dictionary from Whisper's transcribe method.
        output_ass_path: The desired output path for the ASS file.

    Returns:
        True if ASS file creation is successful, False otherwise.
    """
    if not transcription_result or 'segments' not in transcription_result:
        logging.error("Invalid or empty transcription result for ASS generation.")
        return False

    header = """[Script Info]
; Script generated by AI Subtitle Generator
Title: Default
ScriptType: v4.00+
WrapStyle: 0
PlayResX: 1280
PlayResY: 720
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,28,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""
    try:
        with open(output_ass_path, 'w', encoding='utf-8') as f:
            f.write(header)
            for segment in transcription_result['segments']:
                start_time_s = segment.get('start')
                end_time_s = segment.get('end')
                text = segment.get('text', "").strip()

                if start_time_s is None or end_time_s is None:
                    logging.warning(f"Skipping segment for ASS due to missing start/end times: {text[:30]}")
                    continue

                start_formatted = format_ass_time(start_time_s)
                end_formatted = format_ass_time(end_time_s)
                
                # Dialogue: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
                dialogue_line = f"Dialogue: 0,{start_formatted},{end_formatted},Default,,0,0,0,,{text}\n"
                f.write(dialogue_line)
        
        logging.info(f"ASS file successfully generated at {output_ass_path}")
        return True
    except Exception as e:
        logging.error(f"Error generating ASS file at {output_ass_path}: {e}")
        return False

# Example usage (commented out as per instructions)
# if __name__ == '__main__':
#     mock_transcription_result = {
#         "text": "Hello world. This is a test.",
#         "segments": [
#             {"id": 0, "seek": 0, "start": 0.0, "end": 2.5, "text": " Hello world.", "tokens": [1, 2], "temperature": 0.0, "avg_logprob": -0.5, "compression_ratio": 1.0, "no_speech_prob": 0.1},
#             {"id": 1, "seek": 0, "start": 2.5, "end": 5.0, "text": " This is a test.", "tokens": [3, 4, 5], "temperature": 0.0, "avg_logprob": -0.4, "compression_ratio": 1.0, "no_speech_prob": 0.05}
#         ],
#         "language": "english"
#     }
#     srt_success = generate_srt(mock_transcription_result, "test_output.srt")
#     print(f"SRT generation successful: {srt_success}")
#     ass_success = generate_ass(mock_transcription_result, "test_output.ass")
#     print(f"ASS generation successful: {ass_success}")

#     mock_transcription_result_problematic = {
#         "text": "Hello world. This is a test.",
#         "segments": [
#             {"id": 0, "seek": 0, "start": 0.0, "end": 2.5, "text": " Hello world."},
#             {"id": 1, "seek": 0, "start": None, "end": 5.0, "text": " This is a test with missing start."},
#             {"id": 2, "seek": 0, "start": 6.0, "end": 123.45, "text": " A segment with a longer duration: 123.45 seconds."}
#         ],
#         "language": "english"
#     }
#     srt_success_prob = generate_srt(mock_transcription_result_problematic, "test_output_problem.srt")
#     print(f"SRT (problematic) generation successful: {srt_success_prob}")
#     ass_success_prob = generate_ass(mock_transcription_result_problematic, "test_output_problem.ass")
#     print(f"ASS (problematic) generation successful: {ass_success_prob}")

#     # Test format_ass_time
#     print(format_ass_time(0))
#     print(format_ass_time(5.25))
#     print(format_ass_time(65.12))
#     print(format_ass_time(3600))
#     print(format_ass_time(3665.789)) # 1:01:05.78
#     print(format_ass_time(7322.01)) # 2:02:02.01
#     print(format_ass_time(-10)) # Invalid input check
#     print(format_ass_time("abc"))# Invalid input check
```
